# Git Workflow

1 | - Always commit and push after a logical set of changes, such as after completing any subtask, feature, or even a single file update like these modifications. This applies to all phases, including planningâ€”do not wait for major milestones.
2 | 
3 | - **Every commit must be pushed immediately.** The project is viewed live on GitHub, so it is critical that the remote repository is always in sync with the latest local changes.
4 | - For AI-assisted changes (e.g., via Kilo Code modes), in modes that permit execute_command (e.g., Code, Debug, potentially Ask), automatically run git status to check for changes, then git add ., commit with descriptive message, and push at the end of each subtask that modifies tracked files. This ensures seamless version control without manual intervention where possible; fallback to manual for restricted modes like Architect/Orchestrator, where the assistant will confirm readiness but the user must execute the git add ., commit, and push commands.
5 | - Err on the side of more commits than fewer, but ensure each commit is logical and meaningful (e.g., atomic changes with descriptive messages like "Add PantryItem model and tests").
6 | - After completing any major planning or implementation phase, commit and push everything to main.
7 | - If at any time you discover unstaged or uncommitted changes while working on something else, immediately commit those changes with a good summary message that includes a note of when and during what task you found them (e.g., 'Commit orphaned changes from initial setup found during planning review on 2025-09-17'). This prevents loss of work and maintains a clean history.
8 | - Treat both code changes (e.g., .py, .ts, .js files with implementation or tests) and markdown documentation updates (e.g., .md files in plans/ for specs, outlines, or decisions) as equally worthy of individual commits and pushes, since they both represent meaningful progress in the iterative TDD and planning workflow.